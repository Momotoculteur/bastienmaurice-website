Nous avons vu pr√©c√©demment des outils pour analyser ton code, tes d√©pendances et image docker, mais de fa√ßon statique appel√© SAST.

Ici je te propose plonger dans le monde du DAST, AKA l'analyse cette fois-ci d√Ætes **dynamique**.

Avoir un syst√®me qui tourne chaque nuit, analyse ton application avec des tests d'intrusions qui analyses ton API et tes endpoints d'acc√®s √† tes autres micro-services, database, etc, et qui en modifie dynamiquement les param√®tres, attribut et contenu, te permet d'avoir encore plus de retour sur la s√©curit√© de ton syst√®me.

Cela va aller du simple bruteforce par des patterns communs, en allant avec tout type d'injections, etc.

Combiner un tel syst√®me avec des daily report et un syst√®me de monitoring & d'alerting avec Grafana, Datadog ou PagerDuty te permet d'avoir une vision int√©grale √† un instant T de l'ensemble des CVE que tu pourrais rencontrer.

## OWASP - Zap Proxy
C'est un outils √©crit en java open source tr√®s connu et tr√®s activement maintenu, qui te permet plusieurs choses :

- D√©couverte de ton API/endpoint, de ton application web avec des syst√®mes de spyder et crawler. Ce sont des sortes de bot qui vont se promener tout seul sur ton site pour en d√©couvrir toute les pages
- Test d'intrusions statique
- Test d'intrusions dynamique

En fin d'analyse, il te d√©voile un rapport avec l'ensemble des vuln√©rabilit√©s qu'il aura rencontre sur ton application. Il les classes selon la criticit√© de la faille d√©tect√©, et te donnes des conseils pour comment les fixer.

### Extension par marketplace
Etant open source, il existe une multitude d'extensions int√©r√©ssante. Tu peux retrouver des rules suppl√©mentaires d'attaques pour am√©liorer l'√©fficacit√© du tool, avoir des outputs de resultats de tes tests sous divers formats, et bien d'autres.

### Tips - Script
Zap Proxy te permet de coder sous divers language (Javascript avec Nashorn engine, Zest, Groovy, Kotlin, Python avec Jython engine, Ruby), des scripts vari√©s te permettant de r√©aliser toute sorte de t√¢che pour des uses cases sp√©cifique que tu aurais besoin et d'am√©liorer dynamiquement ses utilit√©s :
 
- **Authentification** : r√©aliser des authentication complexe
- **Http Sender** : script appel√© √† chaque requ√™te/r√©ponse
- **Session mangement** : g√®re comment les sessions sont maintenu dans ton app
- **Stand alone** : appel√© manuellement par ta main
- **Targeted** : comme le Stand Alone, mais avec une target bien sp√©cifique
- Et bien d'autres üî•

### Tips - Authentification
#### Authentification simple
Afin que Zap proxy analyse et test ton site dans sa globalit√©, il est n√©cessaire si tu as une partie avec de l'authentification, par exemple un site web de vente en ligne, de lui fournir les instructions pour √™tre logg√© comme un vrai utilisateur.  

Pour cela tu peux tr√®s bien lui indiqu√© une simple page de connexion, avec un username/password traditionnel √† remplir avec un syt√®me de bouton basique. Tu devras lui fournir aussi un syst√®me lui permettant de se rendre compte si il a bien r√©ussi son authentification (ex, acc√®s √† une page sp√©cifique √† un compte utilisateur).

#### Authentification complexe
Il fonctionne notemment avec les sites web moderne √† base d'OIDC (OpenID Connect), OAuth ou encore Kong, qui se base sur une authentification avec un serveur sp√©cifique, des redirections sp√©cifiques, peut √™tre m√™me avec des sytemes de token, bearer token, JWT, etc. Pour r√©aliser ce genre d'authentification complexe, tu devras utiliser un script sp√©cifique selon ton type d'authent recherch√©, vu dans la section plus haut.

!!! tip
    **J'ai d√©j√† r√©alis√© ce type d'authentification, explications et code disponible ici : [Blog DeeplyLearning](https://deeplylearning.fr/cybersecurite/tests-dynamiques-de-securite-dast-sous-owasp-zap-avec-authentification-via-jwt-bearer-token-openid-connect-oauth-kong/)**


### Exemple
#### Fonctionnement basique 

Si tu souhaites juste faire une premi√®re utilisation pour voir comment il fonctionne, tu peux te baser sur les scripts build-in : 

- zap-api-scan.py
- zap-baseline-scan.py
- zap-full-scan.py

#### Script built-in avec app en ligne

Je te montre ici comment industrialiser le process en CI/CD, si tu souhaites tester une application web qui tourne d√©j√† sur ton serveur : 

```yaml linenums="1"
owasp_zap_scan:
  stage: security_scan
  image: zaproxy/zap-stable
  before_script:
    - mkdir -p /zap/wrk
  script:
    - /zap/zap-full-scan.py -t "http://example.com" -r htmlreport.html
  artifacts:
    when: always
    paths:
      - /zap/wrk/htmlreport.html
```

#### Script built-in avec app en local
Si tu souhaites √† l'inverse tester une application en localhost avant de la pousser en ligne afin de t'assurer que l'application soit d√©pourvue de CVE, tu peux la lancer depuis ta pipeline avec les Gitlab Services.


```yaml linenums="1"
owasp_zap_scan:
  stage: security_scan
  image: zaproxy/zap-stable
  before_script:
    - mkdir -p /zap/wrk
  services:
    - name: $mon_registry:$mon_tag
      alias: mon-app
  script:
    - /zap/zap-full-scan.py -t "http://mon-app:mon-port" -r htmlreport.html
  artifacts:
    when: always
    paths:
      - /zap/wrk/htmlreport.html
```

Dans le cas ou tu utilises un registry priv√©, tu dois g√©rer ton `docker login`pour pouvoir pull ton image sans soucis.  

Je te donne ici un exemple de configuration si tu g√®res tes propres Gitlab runners en self-hosted, te permette de g√©rer cet authentification.  

Ici je te montre pour acc√©der au registry de Docker.io : 
```toml
[[runners]]
  executor = "docker"
  environment = ["DOCKER_AUTH_CONFIG={\"auths\":{\"https://index.docker.io/v1/\":{\"auth\":\"base_64\"}}}"]
  [runners.docker]
      environment = ["DOCKER_AUTH_CONFIG={\"auths\":{\"https://index.docker.io/v1/\":{\"auth\":\"base_64"}}}"]
```

A toi de remplacer la partie **base_64** par l'output de la commande suivante :
```bash
echo -n "username:password" | base64
```

!!!note
    Dans le cas ou tu n'ais pas acc√®s √† la configuration de tes runners, tu peux utiliser les Gitlab Variables et y d√©finir **DOCKER_AUTH_CONFIG** de la m√™me fa√ßon dans un **before_script** par exemple.


#### Fonctionnement avec authentification complexe
Pour r√©aliser ton pentest, tu vas devoir comprendre comment le mettre en place.

Tu dois d'abord lancer le Daemon de ZAP. C'est un simple serveur qui va tourner et attendre des instructions. Pour cela, √† partir de l'image officiel de zap, tu peux t'en sortir facilement avec `./zap-x.sh`, disponible √† la racine de l'image officiel. 

La version `./zap.sh` est la m√™me mais avec l'UI. Donc en CI/CD, on l'√©vitera.

Une fois le daemon lanc√©, tu peux interagir avec ce serveur avec des scripts en Python en utilisant le SDK de ZAP via son package PyPi.  Libre √† toi de faire ton propre utilisation custom (Chose que j'avais r√©alis√© chez Thales histoire d'avoir quelque chose qui fit 100% nos besoin en terme d'analyse). Par example :

1. Attendre de fa√ßon script√© le lancement du daemon ZAP (et donc d'avoir un sleep en dur)
2. Lancer le spyder simple 
3. Lancer le spyder ajax
4. Lancer le scan passif
5. Lancer le scan actif
6. G√©n√©rer le repport de r√©sultat en HTML
7. Shutdown le serveur







 