# Kubernetes and Cloud Native Associate (KCNA)

Bastien MAURICE
<!-- .slide: data-background="#009485" -->
<!-- .slide: class="center" -->
---
<div style="text-align: left;">

## Hello ! 

</div>


<img src="../../../ressource/img/profile/photo.jpeg" style="border-radius: 50%; width: 200px;" alt="Photo de profil" />

2 ans DevOps Engineer - Thales<br>
2 ans Platform Engineer - Betclic<br>
Actuellement Platform Engineer - Floa

</br></br>

#### Et vous ?

</div>
---
<div style="text-align: left;">

## Certification liste

**Kubernetes and Cloud Native Associate (KCNA)**  
Kubernetes and Cloud Native Security Associate (KCSA)  

Certified Kubernetes Application Developer (CKAD)  
Certified Kubernetes Administrator (CKA)  

Certified Kubernetes Security Specialist (CKS)  

</div>
---

<div style="text-align: left;">

## Examen

- 60 questions à choix multiples  
- 75 % de bonnes réponses requises  
- Durée : 90 minutes  
- Aucun point négatif (pas de malus)  
- Certification valable 2 ans  
- 1 tentative de rattrapage autorisée

</div>

---

<div style="text-align: left;">

## Objectifs de la journée

- Comprendre Kubernetes, son architecture et ses fondamentaux
- Se familiariser avec l’orchestration de conteneurs
- Découvrir l’architecture Cloud Native et les bonnes pratiques
- Comprendre l’observabilité et le delivery dans l’écosystème Kubernetes
- Se préparer à la certification KCNA (Kubernetes & Cloud Native Associate)

</div>
---

<div style="text-align: left;">

## Plan de formation (7h)

| Domaine                           | % de l'examen | Temps alloué |
| --------------------------------- | ------------- | ------------ |
| Kubernetes Fundamentals           | 46%           | 3h13         |
| Container Orchestration           | 22%           | 1h32         |
| Cloud Native Architecture         | 16%           | 1h07         |
| Cloud Native Observability        | 8%            | 34min        |
| Cloud Native Application Delivery | 8%            | 34min        |

</div>

---

# Kubernetes Fundamentals
#### Resources, Archi, API, Containers, Scheduling...

<!-- .slide: data-background="#009485" -->
<!-- .slide: class="center" -->

---

## Accronymes communs

- K8s = Kubernetes
- CNCF = Cloud Native Computing Foundation
- NetPol = Network Policies
- PV = Persistent Volumes
- PVC = Persistent Volume Claims
- CSI = Container Storage Interface
- CNI = Container Network Interface
- CI/CD = Continuous Integration & Continuous Deployment
- RBAC = Role Based Access Control
- OCI = Open Container Initiative
- CRI = Container Runtime Interface
- SMI = Service Mesh Interface
- SLO = Service Level Objectives
- SLI = Service Level Indicators
- SLA = Service Level Agreements

---
<div style="text-align: left;">

## Qu'est-ce que Kubernetes ?

- Plateforme d'orchestration de conteneurs
- Initialement développé pabr Google, maintenant un projet de la CNCF
- Automatise :
  - Le déploiement
  - Le scaling
  - La gestion du cycle de vie des conteneurs
</div>
---
<div style="text-align: left;">

## Architecture de Kubernetes - Control plane

Le **Control Plane** orchestre l’état global du cluster.

#### 🔧 Composants principaux :
- 🧭 **kube-apiserver**  
  Point d’entrée (REST API) – communication centralisée.
- 📘 **etcd**  
  Base de données clé/valeur — état du cluster.
- 🧠 **kube-scheduler**  
  Planifie les pods sur les nœuds.
- 🛡️ **kube-controller-manager**  
  Gère les boucles de contrôle (réplicas, endpoints…).
- 🔐 **cloud-controller-manager** *(optionnel)*  
  Intégration cloud provider (load balancers, volumes...).

💡 **Fonctionnement :**
- Tu appliques un manifeste → `kube-apiserver` l’enregistre dans `etcd`.
- `scheduler` choisit un nœud → `controller-manager` s’assure que l’état voulu est atteint.
  
</div>

---

<div style="text-align: left;">

## Architecture de Kubernetes - Worker node

Chaque **Worker Node** exécute les pods applicatifs.

##### 🔩 Composants principaux :
- 🧱 **kubelet**  
  Agent qui communique avec le control plane.  
  → Exécute les pods, assure leur santé.
- 📦 **container runtime**  
  Ex: `containerd`, `CRI-O`, `Docker`  
  → Lance les conteneurs définis dans les pods.
- 🌐 **kube-proxy**  
  Gère le réseau, le routage interne des services.

📦 **Les pods sont lancés ici**, pas sur le control plane !  
Chaque nœud est contrôlé par le scheduler et le control plane.

</div>
---

<div style="text-align: left;">

## Architecture de Kubernetes - Schéma

</div>

![kubernetes-control-and-worker-node](./img/kubernetes-control-and-worker-node.png)

---
<div style="text-align: left;">

## VMs vs Container - Rappels 

|             | **VM (Virtual Machine)** | **Container**                |
| ----------- | ------------------------ | ---------------------------- |
| OS inclus   | ✅ Oui (OS complet)       | ❌ Non (partage du noyau)     |
| Démarrage   | 🐢 Lent (minutes)         | ⚡ Rapide (secondes)          |
| Isolation   | 🔒 Forte                  | 🧩 Plus légère                |
| Poids       | 📦 Lourd (Go)             | 🪶 Léger (Mo)                 |
| Portabilité | 🔁 Moins portable         | 🌍 Très portable              |
| Cas d'usage | 🏢 Legacy, multi-OS       | ☁️ Microservices, cloud natif |

- Les conteneurs sont idéaux pour des déploiements rapides, reproductibles et efficaces
- Les VM restent utiles pour l’isolation forte et les environnements hétérogènes.


</div>

![vm-vs-container](./img/vm-vs-container.png)


---
<div style="text-align: left;">

## Docker & container - Rappels - TODOOOOO

TODO

</div>

---
<div style="text-align: left;">

## KubeCTL

Utilisé pour interagir avec l'API Server de Kube

💡 **Tips**
- `kubectl get pods` → voir les pods
- `kubectl describe pod mon-pod` → détails
- `kubectl delete -f mon-fichier.yaml` → suppression

</br>

#### Commandes disponible 
- annotation  
- **apply**  
- auth
- autoscale
- cp
- **create**
- **delete**
- **describe**

</div>
---
<div style="text-align: left;">

## Exemple de manifeste YAML (Pod)


```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mon-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
```

```bash
kubectl apply -f mon-fichier.yaml
```

- Envoie un **fichier manifeste** au serveur Kubernetes.
- Kubernetes **interprète** le YAML pour créer/modifier la ressource déclarée.


</div>

---

<div style="text-align: left;">

## Pods – L'unité de base dans Kubernetes

### Qu’est-ce qu’un Pod ?  
- Plus petite unité déployable dans Kubernetes  
- Contient un ou plusieurs **conteneurs** partageant le même réseau et stockage  
- Cycle de vie lié, s'exécutent sur un **Node** du cluster

### Caractéristiques  
- Partage d’IP et de ports entre les conteneurs du Pod 🌐  
- Éphémère : les Pods peuvent être recréés, remplacés, mais ne sont pas persistants  
- Géré par des contrôleurs comme **Deployment**, **ReplicaSet**

### Exemple simplifié  
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
```

💡 Les Pods sont la **brique de base** sur laquelle Kubernetes construit des applications complexes

</div>

---

<div style="text-align: left;">

## Replicaset – Maintien du nombre de Pods

### Qu’est-ce qu’un ReplicaSet ?  
- Ressource Kubernetes qui garantit un **nombre fixe de Pods** en fonctionnement  
- Crée ou supprime des Pods pour correspondre au nombre désiré  
- Assure la haute disponibilité des applications

### Fonctionnement  
- Utilise un **label selector** pour gérer les Pods ciblés  
- **Déployé généralement via un Deployment** (rarement seul)

### Exemple simple  
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: myapp-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp-container
        image: nginx:latest
```

💡 ReplicaSet assure la résilience en maintenant toujours le bon nombre de Pods

</div>

---
<div style="text-align: left;">

## Deployments – Gestion des applications

#### Qu’est-ce qu’un Deployment ?  
- Ressource Kubernetes qui gère le **déploiement et la mise à jour** des Pods  
- Assure le nombre désiré de réplicas disponibles 🔄  
- Permet le **rolling update** sans interruption de service  

#### Fonctionnalités clés  
- Scaling automatique ou manuel 📈📉  
- Rollback automatique en cas d’erreur ⏪  
- Stratégies de mise à jour (RollingUpdate, Recreate)

#### Exemple  
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp-container
        image: nginx:latest
```

💡 Deployments simplifient la gestion du cycle de vie des applications dans Kubernetes

</div>

---
<div style="text-align: left;">

## Stateless vs Stateful 

### Stateless  
- Pas de conservation d’état entre les requêtes  
- Chaque requête est indépendante  
- Facile à scaler horizontalement  
- Exemple : serveur web statique, API REST sans session

### Stateful  
- Conservation d’état entre les requêtes  
- Nécessite gestion de la session ou des données persistantes  
- Plus complexe à scaler et à gérer  
- Exemple : base de données, applications avec session utilisateur


💡 Kubernetes favorise les workloads **stateless**, mais supporte aussi les **stateful** via StatefulSets, PV, PVC

</div>
---

<div style="text-align: left;">

## Namespaces - Isolation & Organisation

#### Qu’est-ce qu’un Namespace ?  
- Espace virtuel pour **isoler et organiser** les ressources Kubernetes  
- Permet de gérer plusieurs environnements ou équipes sur un même cluster   
- Les noms des ressources sont uniques **dans un namespace** (pas globalement)

#### Utilités  
- Séparer dev, test, prod  
- Appliquer des politiques RBAC différentes   
- Limiter les ressources consommées par namespace 

#### Exemple  
```bash
kubectl get namespaces
kubectl create namespace mon-projet
```

💡 Les namespaces facilitent la **gestion multi-tenant** et la sécurité dans Kubernetes 🔄
</div>
---

<div style="text-align: left;">

## Services et mise en réseau

- ClusterIP : communication interne
- NodePort : expose un port sur chaque noeud
- LoadBalancer : provisionne un LB (cloud)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  type: NodePort
  selector:
    app: myapp
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30036
```
</div>


---

<div style="text-align: left;">

## Volumes 

#### 🔍 Qu’est-ce qu’un Volume ?  
- Espace de stockage **monté dans un pod**  
- Permet de **persister les données** au-delà du cycle de vie du conteneur  
- Types variés : `emptyDir`, `hostPath`, `configMap`, `secret`, `persistentVolumeClaim`, etc.

#### ⚙️ Fonctionnement  
- Déclaré dans le spec du pod  
- Utilisé par un ou plusieurs conteneurs via un **mountPath**  
- Garantit la disponibilité des données durant l’exécution du pod

#### 📝 Exemple simple avec `emptyDir`  
```yaml
volumes:
- name: cache-volume
  emptyDir: {}
containers:
- name: app
  image: busybox
  volumeMounts:
  - mountPath: /cache
    name: cache-volume
```

💡 Les volumes sont essentiels pour gérer la **durabilité des données** dans Kubernetes

</div>

---
<div style="text-align: left;">

## Persistent Volumes

#### 📌 Qu’est-ce qu’un PV ?  
- Ressource **abstraite** représentant un espace de stockage dans le cluster  
- Créée **manuellement** ou **automatiquement** via une StorageClass  
- Utilisée via un `PersistentVolumeClaim` (PVC)

#### 🔄 Cycle de vie  
- **Available** → Libre  
- **Bound** → Attaché à un PVC  
- **Released** → Libéré mais pas encore réutilisable  
- **Failed** → Erreur

#### 🛠️ Exemple  
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-example
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

💡 PV = ressource physique ou virtuelle de **stockage durable**, indépendante du pod
</div>

---
<div style="text-align: left;">

## Persistent Volume Claim

#### 📌 Qu’est-ce qu’un PVC ?  
- Requête de **stockage persistant** par un utilisateur ou une application  
- Demande un volume avec une capacité et des caractéristiques spécifiques  
- Lie un Pod à un **Persistent Volume (PV)** disponible

#### 🧩 Fonctionnement  
- Kubernetes cherche un PV compatible (capacity, accessModes, storageClass)  
- Une fois trouvé, le PV est **bindé** au PVC  
- Le Pod utilise ensuite le PVC pour accéder au stockage

#### 🛠️ Exemple  
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-example
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: fast-ssd
```

💡 PVC = interface utilisateur pour demander du stockage persistant dans Kubernetes

</div>
--- 
<div style="text-align: left;">

## Storage Class

#### 📦 Qu’est-ce qu’une StorageClass ?  
- Définit **le type de stockage dynamique** utilisable par les volumes  
- Utilisée pour provisionner automatiquement un `PersistentVolume` (PV) à partir d’un `PersistentVolumeClaim` (PVC)

#### 🧰 Paramètres possibles  
- Type de provisioner (ex: `kubernetes.io/aws-ebs`, `csi`)  
- ReclaimPolicy : `Retain`, `Delete`, `Recycle`  
- AccessModes : `ReadWriteOnce`, `ReadOnlyMany`, `ReadWriteMany`  
- `allowVolumeExpansion`: true/false

#### 📄 Exemple  
```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
```

💡 Le PVC choisit une `StorageClass` pour demander un **stockage adapté et automatisé**

</div>
---

<div style="text-align: left;">

## RBAC et sécurité de base

#### 👤 ServiceAccounts  
- Identité utilisée par les **pods** pour s’authentifier auprès de l’API Kubernetes  
- Montée automatiquement dans les pods (`/var/run/secrets/...`)  
- Par défaut : `default` dans chaque namespace  
➡️ Utiliser des comptes dédiés pour les apps sensibles

#### 🛡️ RBAC (Role-Based Access Control)  
- Contrôle **qui peut faire quoi** sur quelles ressources  
- Principaux objets :
  - `Role` / `ClusterRole` : ensemble de permissions  
  - `RoleBinding` / `ClusterRoleBinding` : association d’une identité à un rôle


💡 🧠 Combinez **ServiceAccount + RBAC** pour sécuriser les accès applicatifs

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

</div>

---
<div style="text-align: left;">

## Exemple : Role + RoleBinding

Donner accès en lecture aux **Secrets** du namespace `dev` à un pod utilisant le `ServiceAccount: reader`

```yaml
# Role : permissions locales
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: read-secrets
  namespace: dev
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
```

```yaml
# RoleBinding : attribution à une identité
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: bind-read-secrets
  namespace: dev
subjects:
- kind: ServiceAccount
  name: reader
roleRef:
  kind: Role
  name: read-secrets
  apiGroup: rbac.authorization.k8s.io
```
</div>
---
<div style="text-align: left;">

## Exemple : ClusterRole + ClusterRoleBinding

Donner accès en lecture à **tous les pods du cluster** à un `ServiceAccount` nommé `auditor`

```yaml
# ClusterRole : permissions globales
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: read-all-pods
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
```

```yaml
# ClusterRoleBinding : attribution globale
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: bind-read-all-pods
subjects:
- kind: ServiceAccount
  name: auditor
  namespace: default
roleRef:
  kind: ClusterRole
  name: read-all-pods
  apiGroup: rbac.authorization.k8s.io
```
</div>

---

<div style="text-align: left;">

## Kubernetes distributions

#### ☁️ Cloud-managed  
- **GKE** (Google Kubernetes Engine)  
- **EKS** (Elastic Kubernetes Service – AWS)  
- **AKS** (Azure Kubernetes Service)  
➡️ Gérés par les fournisseurs cloud, intégrés à leurs services

#### 🏗️ On-premise & DIY  
- **kubeadm** : installation manuelle, flexible  
- **RKE** : Rancher Kubernetes Engine  
- **MicroK8s**, **Minikube**, **k3s** : légers, idéals pour dev/test

#### 🧩 Autres distributions populaires  
- **OpenShift** (Red Hat) : Kubernetes + outils CI/CD, sécurité intégrée  
- **VMware Tanzu**, **Canonical Charmed K8s**, etc.


</div>

---

<div style="text-align: left;">

## Questions : Kubernetes Fundamentals

1. Quel composant stocke l'état du cluster ?

2. Quelle est la différence entre un Pod et un Deployment ?

3. Quel type de Service dois-je utiliser pour exposer publiquement un Pod ?

4. Quelle commande permet d'appliquer un fichier YAML ?

</div>

---

# Container Orchestration 
#### Container, Runtime, Security, Networking, Service mesh, Storage...

<!-- .slide: data-background="#009485" -->
<!-- .slide: class="center" -->


---

## Runtime 

#### 🔍 Qu’est-ce qu’un Runtime ?  
- Logiciel responsable de **l’exécution des conteneurs** sur chaque nœud  
- Interface entre Kubernetes (via **kubelet**) et le système d’exploitation

#### 🔄 Compatibilité avec Kubernetes  
- Kubernetes utilise le standard **Container Runtime Interface (CRI)**  
- Permet d’utiliser différents runtimes conformes :  
  - **containerd** (par défaut)  
  - **CRI-O**  
  - (Docker n’est plus directement supporté)

#### 📦 Rôle du runtime  
- Télécharger les images  
- Créer, exécuter, stopper et supprimer les conteneurs  
- Gérer les volumes et le réseau

---
<div style="text-align: left;">

## Helm

#### 📦 Qu’est-ce que Helm ?  
- **Gestionnaire de packages Kubernetes**  
- Permet d’installer, configurer et maintenir des applications via des **charts**

#### 🧩 Concepts clés  
- **Chart** : ensemble de fichiers YAML modélisant une app (templates + valeurs)  
- **Values.yaml** : fichier de configuration personnalisable  
- **Release** : instance déployée d’un chart

#### 🚀 Commandes utiles  
```bash
helm repo add bitnami https://charts.bitnami.com/bitnami
helm install myapp bitnami/nginx
helm upgrade myapp bitnami/nginx --set service.type=NodePort
```

💡 Helm = gain de temps, réutilisabilité, déploiements propres & reproductibles

</div>

---

## Kustomize 

### Qu’est-ce que Kustomize ?  
- Outil natif Kubernetes pour **personnaliser les manifests YAML**  
- Permet de créer des variantes sans dupliquer les fichiers  
- Basé sur une approche **patch & overlay**

### Fonctionnalités clés  
- Ajout/modification de labels, annotations  
- Fusion ou remplacement de champs dans les manifests  
- Gestion de plusieurs environnements (dev, staging, prod) facilement  
- Support des ConfigMaps et Secrets générés à la volée

### Exemple simple  
```bash
kustomization.yaml
resources:
  - deployment.yaml
  - service.yaml

patchesStrategicMerge:
  - patch.yaml
```

💡 Kustomize facilite la **gestion déclarative** et la réutilisation des configurations Kubernetes
---

<div style="text-align: left;">

## Jobs 

- Exécutent une **tâche unique** jusqu’à réussite  
- Utilisés pour des traitements batch, migrations, scripts d’initialisation  
- Gérés automatiquement (relances si échec)

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello-job
spec:
  template:
    spec:
      containers:
      - name: hello
        image: busybox
        command: ["echo", "Hello KCNA!"]
      restartPolicy: Never
  backoffLimit: 3
```

</div>

---
<div style="text-align: left;">

## CronJobs

- Planifient des **Jobs à intervalles réguliers**  
- Syntaxe similaire à `cron` (ex: `0 * * * *`)  
- Exemples : sauvegardes, envois récurrents, tâches de nettoyage

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello-cronjob
spec:
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            command: ["echo", "Hello every 5 minutes!"]
          restartPolicy: OnFailure
```

</div>
---

<div style="text-align: left;">

## Autoscaling des Pods

Permet d'ajuster à la demande, sans aucune intervention manuelle, les ressources en CPU/RAM  

S'adapte selon le traffic users, selon des règles & events

</br>

#### Horizontal Pod Autoscaler (HPA)  
- Ajuste automatiquement le nombre de pods en fonction de métriques (CPU, mémoire, custom)  
- Permet de gérer la charge variable sans intervention manuelle  

#### Vertical Pod Autoscaler (VPA)  
- Ajuste automatiquement les ressources (CPU, mémoire) allouées aux pods  
- Optimise les performances sans changer le nombre de pods  

</div>

---
<div style="text-align: left;">


## Autoscaling des Nodes

#### Cluster Autoscaler (CA)  
- Ajuste automatiquement le nombre de nœuds du cluster selon la charge  
- Supprime les nœuds inutilisés pour optimiser les coûts  

#### Karpenter  
- Autoscaler dynamique et intelligent, développé par AWS  
- Optimise la planification des nœuds, rapide et flexible  
- Supporte divers fournisseurs cloud et configurations

💡 **Autoscaling global = meilleure disponibilité et maîtrise des coûts**

</div>

---
## Serverless & Function as a Service (FaaS)

### Qu’est-ce que le Serverless ?  
- Exécution de code sans gérer l’infrastructure serveur  
- Facturation à l’usage (par invocation ou durée d’exécution)  
- Auto-scalabilité automatique

### Function as a Service (FaaS)  
- Micro-fonctions légères déclenchées par des événements  
- Exemple : AWS Lambda, Azure Functions, Google Cloud Functions

### OpenFaaS  
- Plateforme FaaS open-source pour Kubernetes  
- Déploiement simple de fonctions en conteneurs  
- Intégration facile avec Kubernetes, auto-scaling inclus  
- Supporte multiples langages et frameworks

💡 Serverless simplifie le déploiement et la gestion d’applications événementielles

---

## Open Standards

### Qu’est-ce qu’un Open Standard ?  
- Norme **ouverte et publique**, accessible à tous  
- Développée et maintenue par une communauté ou un organisme indépendant  
- Favorise l’interopérabilité entre différents systèmes et fournisseurs

### Pourquoi c’est important ?  
- Évite la **dépendance propriétaire** (vendor lock-in)  
- Facilite la collaboration et l’intégration  
- Assure la pérennité et l’évolution des technologies

### Exemples dans Kubernetes & Cloud Native  
- **OpenTelemetry** : standard d’instrumentation et de télémétrie  
- **CNCF** : défini plusieurs standards et spécifications  
- **OCI** (Open Container Initiative) : standards pour conteneurs et images
- **CNI** (Container Networking Interface) : standards pour les interfaces réseaux sur les containers Linux
- **CRI** (Container Runtime Interface) : standards pour les interfaces entre kubelet et container runtime


💡 Utiliser des standards ouverts favorise un écosystème robuste et flexible

---

<div style="text-align: left;">

## Custom Resource Definitions (CRDs)

#### 🔧 Extension de l’API Kubernetes  
- Permettent de **définir de nouveaux types de ressources** personnalisées  
- Facilite l’ajout de fonctionnalités spécifiques sans modifier le cœur Kubernetes

#### 🌟 Exemples courants  
- **cert-manager** : gestion automatisée des certificats SSL/TLS  
- **Prometheus Operator** : gestion simplifiée des instances Prometheus  

💡 **Les CRDs ouvrent la voie à un Kubernetes extensible et adaptable aux besoins métiers !**

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: monitoring.coreos.com/v1
```

</div>

---

<div style="text-align: left;">

## Questions : Orchestration

1. Qu'est-ce qu'un chart Helm ?

2. Différence entre Job et CronJob ?

3. Pourquoi utiliser un CRD ?

</div>

---


# Cloud Native Architecture

<!-- .slide: data-background="#009485" -->
<!-- .slide: class="center" -->
---

<div style="text-align: left;">

## Microservices VS Monolitique - Définition - TODOOOOOO

|                    | **Monolithe**                     | **Microservices**               |
|--------------------|----------------------------------|--------------------------------|
| Architecture       | Application unique, tout-en-un   | Application découpée en services indépendants |
| Déploiement        | Un seul déploiement global       | Déploiements indépendants par service          |
| Scalabilité        | Scalabilité globale (tout ou rien) | Scalabilité ciblée par service                  |
| Maintenance        | Complexe et risquée               | Plus simple, services isolés                     |
| Technologies       | Une seule stack souvent           | Possibilité d’utiliser plusieurs stacks         |
| Résilience         | Défauts impactent toute l’app    | Isolation des pannes limitée à un service        |

💡 **Le microservice favorise agilité, évolutivité et résilience, clés du Cloud Native !**

</div>

---

## Microservices - ConfigMap

#### 📂 ConfigMaps  
- Stockent les **configurations non sensibles** (fichiers de config, variables d’environnement)  
- Séparent la configuration du code → facilite les mises à jour sans redéployer l’app  
- Doivent rester **lisibles** et non sensibles  

💡 **Astuce :** utiliser des volumes ou variables d’environnement pour injecter ConfigMaps/Secrets dans les pods en évitant la duplication.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mon-configmap
  namespace: default
data:
  APP_ENV: "production"
  APP_DEBUG: "false"
  DATABASE_URL: "postgres://user:pass@db:5432/ma_db"
```


</div>


---

## Microservices - Secret

#### 🗝️ Secrets  
- Stockent les **informations sensibles** (mots de passe, clés API, certificats)  
- Encodés en Base64, mais **pas chiffrés** par défaut → utiliser un gestionnaire externe pour plus de sécurité (ex: Vault)  
- Limiter l’accès aux secrets via les **RBAC**  

💡 **Astuce :** utiliser des volumes ou variables d’environnement pour injecter ConfigMaps/Secrets dans les pods en évitant la duplication.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mon-secret
  namespace: default
type: Opaque
data:
  DB_USER: dXNlcg==       # "user" encodé en base64
  DB_PASSWORD: cGFzc3dvcmQ=  # "password" encodé en base64
```

---

<div style="text-align: left;">

## Service Mesh

#### Principaux outils  
- **Istio**, **Linkerd**

#### Fonctions clés  
- 🔀 **Routage** avancé du trafic entre services  
- 📊 Collecte de **métriques** fines au niveau service  
- 🔐 Sécurité renforcée via **mTLS** (mutual TLS)  

💡 **Bénéfices** : visibilité, contrôle et sécurité renforcée pour les communications inter-services.

</div>

---

<div style="text-align: left;">

## Questions : Architecture

1. Quelle est la responsabilité d'un Service Mesh ?

2. Quelle différence entre Secret et ConfigMap ?

3. Quel composant rend un conteneur stateless ?

</div>

---


# Cloud Native Observability
#### Telemetry, Prom, Cost management...

<!-- .slide: data-background="#009485" -->
<!-- .slide: class="center" -->
---

<div style="text-align: left;">

## Prometheus & Grafana

#### ⬇️ Prometheus  
- Récupération des métriques par **pull**  
- Stockage et requêtage des données métriques  
- Système d’**alerting** intégré  

#### 📈 Grafana  
- Création de **dashboards** visuels personnalisés  
- Visualisation en temps réel des métriques et alertes  
- Supporte plusieurs sources de données  

---

💡 **Objectif Cloud Native** : surveillance proactive et analyse visuelle centralisée !


(ajout de schéma)

</div>

---

<div style="text-align: left;">

## Logging et Tracing

#### 📚 Logging
- **Fluentd**, **Loki** : collecte, centralisation et recherche des logs  
- Logs essentiels pour le debug et monitoring

#### 🕵️‍♂️ Tracing
- **Jaeger** : suivi des requêtes distribuées  
- Analyse des performances et goulots d’étranglement

#### 📏 OpenTelemetry
- Standard ouvert d’instrumentation  
- Unifie collecte de métriques, logs, traces

💡 **Focus Cloud Native** : observabilité complète pour diagnostiquer efficacement !

</div>

---

<div style="text-align: left;">

## Questions : Observabilité

1. Quelle est la différence entre Prometheus et Grafana ?

2. Quel outil permet de centraliser les logs ?

3. Quel protocole est utilisé pour les traces distribuées ?

</div>

---

# Cloud Native Application Delivery
#### Apps fundamentals, GitOps, CI/CD...kcna 
<!-- .slide: data-background="#009485" -->
<!-- .slide: class="center" -->

---

<div style="text-align: left;">

## CI/CD et GitOps

#### 🔧 CI/CD (Intégration & Déploiement continus)
- **Jenkins**, **GitLab CI** : automatisent build, tests, déploiement
- Pipelines décrits sous forme de fichiers (`Jenkinsfile`, `.gitlab-ci.yml`)

#### 🌿 GitOps
- Déploiement **déclaratif** via Git (source de vérité)
- Ex : **ArgoCD**, **FluxCD**
- Suivi des changements via Git → synchronisation automatique avec le cluster

💡 **Objectif Cloud Native** : automatiser, versionner et sécuriser les déploiements !


</div>

---

<div style="text-align: left;">

## Sécurité de livraison 

#### 🚦 Admission Controllers  
- Contrôlent et valident les requêtes API avant leur application  
- Permettent d’imposer des politiques de sécurité, conformité, bonnes pratiques  

#### 🛡️ OPA & Gatekeeper  
- OPA (Open Policy Agent) : moteur de politique flexible  
- Gatekeeper : implémentation Kubernetes d’OPA pour appliquer des règles personnalisées  

#### 🔍 Scan d’images  
- **Trivy**, **Snyk** : détectent vulnérabilités, failles de sécurité dans les images conteneurs  
- Intégration possible dans pipelines CI/CD pour blocage précoce  

💡 **But : garantir la sécurité et la conformité avant déploiement en production !**

</div>

---

<div style="text-align: left;">

## Questions : Delivery

1. Qu'est-ce que GitOps ?

2. Quelle est la différence entre un pipeline CI et CD ?

3. Quel outil permet de scanner une image de conteneur ?

</div>

---

<div style="text-align: left;">

## Quizz - Examen blanc

</div>

---

<div style="text-align: left;">

## Conseils de préparation

- 🎯 **60 questions gratuites** disponibles sur [app.exampro.co](https://app.exampro.co)  
- 💸 **Séries supplémentaires** disponibles sur Udemy (payantes)
- ⏱️ **Entraîne-toi au rythme réel** : ~1min30 par question  
  → Ne reste pas bloqué trop longtemps
- 💡 **Se méfier des pièges de vocabulaire**  
  Lire attentivement chaque proposition.

</div>

---

<div style="text-align: left;">

## Plan de Révision Express – KCNA

#### 🎓 Concepts fondamentaux
- Qu’est-ce qu’un cluster Kubernetes ?
- Architecture : Control Plane vs Workers
- Principales ressources : Pod, Service, Deployment, ConfigMap, Secret

#### ⚙️ Outils CLI
- `kubectl` : commandes de base (`get`, `describe`, `logs`, `apply`, `delete`)
- Notions de contexte (`kubectl config use-context`)

#### 📦 Conteneurs & images
- Docker / containerd / OCI
- Fichier Dockerfile & `docker build`

#### 🌐 Réseau & Services
- ClusterIP, NodePort, LoadBalancer
- DNS interne, communication entre pods

#### ☁️ Écosystème CNCF
- Open source, projets CNCF (Prometheus, Helm, etc.)
- CNCF Landscape et notions de Cloud Native

</div>